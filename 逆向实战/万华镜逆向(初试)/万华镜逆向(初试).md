---
title: 万华镜逆向(初试)
date: 2024-03-02 15:05:25
tags:
password: md5(wtf?do_you_want_my_passwd???!!!nonono!!!)
---

# 教程

![img](万华镜逆向(初试)/images/image.png)
![img](万华镜逆向(初试)/images/image-1.png)
![img](万华镜逆向(初试)/images/image-2.png)
![img](万华镜逆向(初试)/images/image-3.png)
![img](万华镜逆向(初试)/images/image-4.png)
![img](万华镜逆向(初试)/images/image-5.png)
![img](万华镜逆向(初试)/images/image-6.png)
![img](万华镜逆向(初试)/images/image-7.png)

```c++
Struct FilePackVer
{
    char sign[0x10];
    DWORD size?;
    DWORD entry?;
    DWORD unknown;
};
```

![img](万华镜逆向(初试)/images/image-8.png)
![img](万华镜逆向(初试)/images/image-9.png)
![img](万华镜逆向(初试)/images/image-10.png)
![img](万华镜逆向(初试)/images/image-11.png)
![img](万华镜逆向(初试)/images/image-12.png)

```c++
DWORD Tohash(void* data, int len)
{
    if (len < 8)
    {
        return 0;
    }
    //准备工作
    __m64 mm0 = _mm_cvtsi32_si64(0);
    __m64 mm1;
    __m64 mm2 = _mm_cvtsi32_si64(0);
    DWORD key = 0xA35793A7;
    __m64 mm3 = _mm_cvtsi32_si64(key);
     mm3 = _m_punpckldq(mm3, mm3);
     __m64* pdata=(__m64*)data;
    //开始循环计算hash
    for (size_t i = 0; i < (len >> 3); i++)
    {
        mm1 = *pdata;
        pdata++;
        mm2 = _m_paddw(mm2, mm3);
        mm1 = _m_pxor(mm1, mm2);
        mm0 = _m_paddw(mm0, mm1);
        mm1 = mm0;
        mm0 = _m_pslldi(mm0, 3);
        mm1 = _m_psrldi(mm1, 0x1D);
        mm0 = _m_por(mm1, mm0);
    }
    mm1 = _m_psrlqi(mm0, 32);
    DWORD result = _mm_cvtsi64_si32(_m_pmaddwd(mm0, mm1));
    _m_empty();//复位浮点寄存器
    return result;
}
```

![img](万华镜逆向(初试)/images/image-13.png)
![img](万华镜逆向(初试)/images/image-14.png)

```c++
void dencrypt(void* data,unsigned int len, DWORD hash)
{
    if (len >> 3 == 0)
    {
        return;
    }
    //准备工作
    DWORD key1 = 0xA73C5F9D;
    DWORD key2 = 0xCE24F523;
    DWORD key3 = (len + hash)^ 0xFEC9753E;
    __m64 mm7 = _mm_cvtsi32_si64(key1);
    mm7 = _m_punpckldq(mm7, mm7);
    __m64 mm6 = _mm_cvtsi32_si64(key2);
    mm6 = _m_punpckldq(mm6, mm6);
    __m64 mm5 = _mm_cvtsi32_si64(key3);
    mm5 = _m_punpckldq(mm5, mm5);
    __m64* datapos = (__m64*)data;
    __m64 mm0;
    for (size_t i = 0; i < len >> 3; i++)
    {
        mm7 = _m_paddd(mm7, mm6);
        mm7 = _m_pxor(mm7, mm5);
        mm0 = *datapos;
        mm0 = _m_pxor(mm0, mm7);
        mm5 = mm0;
        *datapos = mm0;
        datapos++;
    }
    _m_empty();//复位浮点寄存器
    return;
}
```

![img](万华镜逆向(初试)/images/image-15.png)

```c++
004ED95B         | 8D85 B4FBFFFF   | lea eax,dword ptr ss:[ebp-0x44C]                   | 缓冲区
004ED961         | 8D95 B8FBFFFF   | lea edx,dword ptr ss:[ebp-0x448]                   | 需要转换的字符串
004ED967         | B9 20000000     | mov ecx,0x20                                       | 字符串长度
004ED96C         | E8 9F9EF1FF     | call <月に寄りそう乙女の作法22.multibyte2widecode>            | 字符转unicode
004ED971         | 8B85 B4FBFFFF   | mov eax,dword ptr ss:[ebp-0x44C]                   |
004ED977         | BA 28DB4E00     | mov edx,月に寄りそう乙女の作法22.4EDB28                       | 4EDB28:L"8hr48uky,8ugi8ewra4g8d5vbf5hb5s6"
004ED97C         | E8 7FA3F1FF     | call <月に寄りそう乙女の作法22.cmp_sign>                      | 比对签名
```

![img](万华镜逆向(初试)/images/image-16.png)

```c++
struct FilePackVer
{
    char sign[0x10];
    DWORD size?;
    QWORD entry?; //写程序的时候需要变成两个int型表示低位和高位，直接用64位整型读取文件的时候会少读这部分数据
};
```

![img](万华镜逆向(初试)/images/image-17.png)

```c++
struct HashData
{
    char sign[0x20];
    DWORD HashVerSize;
    char data[0x100];
    DWORD Unkown; //就是那个大于8或者小于0就设置成0的数据
    char Blank[0x2F8]; //一大片用0填充的数据，应该是用于占位
    FilePackVer fpacker;
};
```

![img](万华镜逆向(初试)/images/image-18.png)

```asm
004ED9D2         | E8 397DF1FF     | call 月に寄りそう乙女の作法22.405710                          | 构造类？
```

![img](万华镜逆向(初试)/images/image-19.png)
![img](万华镜逆向(初试)/images/image-20.png)
![img](万华镜逆向(初试)/images/image-21.png)
![img](万华镜逆向(初试)/images/image-22.png)
![img](万华镜逆向(初试)/images/image-23.png)
![img](万华镜逆向(初试)/images/image-24.png)
![img](万华镜逆向(初试)/images/image-25.png)
![img](万华镜逆向(初试)/images/image-26.png)
![img](万华镜逆向(初试)/images/image-27.png)

```c++
//chr是逐个从数据中取出的字节，t_pos是表的下标
//这里有两张表，一张是table，刚刚从0-FF复制过来的，另一张是other，不做任何预处理
while (1)
{
    if (chr > 0x7Fu)
    {
        t_pos += chr - 127;
        chr = 0;
    }
    if (t_pos > 0xFF)
    {
        break;
    }
 
    for (size_t i = 0; i < chr + 1; i++)
    {
        table[t_pos] = *datapos++;
        if (t_pos != (unsigned __int8)table[t_pos])
        {
            other[t_pos] = *datapos++;
        }
 
        ++t_pos;
    }
    if (t_pos > 0xFF)
    {
        break;
    }
    chr = *datapos++;
}
```

![img](万华镜逆向(初试)/images/image-28.png)

```c++
Dencrypt2DataOutput* dencrypt2(void* data, unsigned int len,unsigned int dencrypted_len, DWORD hash)
{
    char Sampletable[0x100],table[0x100],other[0x100];
    for (size_t i = 0; i < 0x100; i++)
    {
        Sampletable[i] = i;
    }
    Dencrypt2DataHead* head = (Dencrypt2DataHead*)data;
    //对比开头是否为0xFF425031
    if (head->sign != 0xFF435031)
    {
        cout << "数据不符合解码条件" << endl;
        return nullptr;
    }
    if (head->size> 0x20000000u)
    {
        cout << "数据量大于0x20000000" << endl;
        return nullptr;
    }
  
    Dencrypt2DataOutput* Output = new Dencrypt2DataOutput();
    Output->len = dencrypted_len;
    Output->data = new BYTE[dencrypted_len + 1];
    BYTE* outputbuff = Output->data;
  
    BYTE* datapos = (BYTE*)data + sizeof(Dencrypt2DataHead);
    BYTE* data_start = datapos;
    BYTE* data_end = (BYTE*)data + len;
    BYTE chr;
    int t_pos;
    int size;
    while (data_start < data_end)
    {
        chr = *data_start;
        datapos = data_start + 1;
        memcpy(table, Sampletable, 0x100);
        t_pos = 0;
        //建表循环
        while (1)
        {
            if (chr > 0x7Fu)
            {
                t_pos += chr - 127;
                chr = 0;
            }
            if (t_pos > 0xFF)
            {
                break;
            }
  
            for (size_t i = 0; i < chr + 1; i++)
            {
                table[t_pos] = *datapos++;
                if (t_pos != (unsigned __int8)table[t_pos])
                {
                    other[t_pos] = *datapos++;
                }
  
                ++t_pos;
            }
            if (t_pos > 0xFF)
            {
                break;
            }
            chr = *datapos++;
        }
        //数据类型判断
        if ((head->isWordType & 1) == 1)
        {
            size = *(WORD*)datapos;
            data_start = (datapos + 2);
        }
        else
        {
            size = *(DWORD*)datapos;
            data_start = (datapos + 4);
        }
        //解密循环
        stack<BYTE> stack;
        while (1)
        {
            BYTE result;
            if (stack.size())
            {
                result = stack.top();
                stack.pop();
            }
            else
            {
                if (!size)
                {
                    break;
                }
                size--;
                result = *data_start;
                data_start++;
            }
            if (result == (BYTE)table[result])
            {
                *outputbuff = result;
                outputbuff++;
            }
            else
            {
                stack.push(other[result]);
                stack.push(table[result]);
            }
        }
    }
    return Output;
}
```

![img](万华镜逆向(初试)/images/image-29.png)

```c++
HashVer 
{
        char sign[16];
        DWORD  table_size;
    DWORD  file_count;
    DWORD  index_size;
    DWORD  data_size;
    DWORD  iscompressed;
    char unknown1[32];
}
```

![img](万华镜逆向(初试)/images/image-30.png)

```asm
004E4C1E         | 53              | push ebx                                           |
004E4C1F         | 56              | push esi                                           |
004E4C20         | 57              | push edi                                           | edi:"0yC"
004E4C21         | 33DB            | xor ebx,ebx                                        |
004E4C23         | 895D FC         | mov dword ptr ss:[ebp-0x4],ebx                     |
004E4C26         | 894D F0         | mov dword ptr ss:[ebp-0x10],ecx                    |
004E4C29         | 8BDA            | mov ebx,edx                                        | edx:"l;p"
004E4C2B         | 8945 F8         | mov dword ptr ss:[ebp-0x8],eax                     |
004E4C2E         | 33C0            | xor eax,eax                                        |
004E4C30         | 55              | push ebp                                           |
004E4C31         | 68 334D4E00     | push 月に寄りそう乙女の作法22.4E4D33                          |
004E4C36         | 64:FF30         | push dword ptr fs:[eax]                            | eax:"^??~8"
004E4C39         | 64:8920         | mov dword ptr fs:[eax],esp                         |
004E4C3C         | 8BC3            | mov eax,ebx                                        | eax等于hash
004E4C3E         | C1E8 10         | shr eax,0x10                                       |
004E4C41         | 25 FFFF0000     | and eax,0xFFFF                                     |
004E4C46         | 33D8            | xor ebx,eax                                        | key = ((hash >> 0x10) & 0xFFFF) ^ hash
004E4C48         | 8B45 F0         | mov eax,dword ptr ss:[ebp-0x10]                    |
004E4C4B         | 33D2            | xor edx,edx                                        | edx:"l;p"
004E4C4D         | E8 D629F2FF     | call 月に寄りそう乙女の作法22.407628                          |
004E4C52         | 8D55 E6         | lea edx,dword ptr ss:[ebp-0x1A]                    |
004E4C55         | B9 02000000     | mov ecx,0x2                                        |
004E4C5A         | 8B45 F8         | mov eax,dword ptr ss:[ebp-0x8]                     |
004E4C5D         | 8B30            | mov esi,dword ptr ds:[eax]                         |
004E4C5F         | FF56 0C         | call dword ptr ds:[esi+0xC]                        | 读取文件
004E4C62         | 66:837D E6 00   | cmp word ptr ss:[ebp-0x1A],0x0                     | 读出的值是否大于等于0
004E4C67         | 7D 16           | jge 月に寄りそう乙女の作法22.4E4C7F                           |
004E4C69         | B9 504D4E00     | mov ecx,月に寄りそう乙女の作法22.4E4D50                       | 4E4D50:L"_LoadStringCode:Out of length error."
004E4C6E         | B2 01           | mov dl,0x1                                         | 小于0就报错
004E4C70         | A1 D4004100     | mov eax,dword ptr ds:[0x4100D4]                    |
004E4C75         | E8 D280F3FF     | call 月に寄りそう乙女の作法22.41CD4C                          |
004E4C7A         | E9 98000000     | jmp 月に寄りそう乙女の作法22.4E4D17                           |
004E4C7F         | 0FBF75 E6       | movsx esi,word ptr ss:[ebp-0x1A]                   |
004E4C83         | 85F6            | test esi,esi                                       |
004E4C85         | 0F8E 8C000000   | jle 月に寄りそう乙女の作法22.4E4D17                           |
004E4C8B         | 56              | push esi                                           | Arg1
004E4C8C         | 8D45 FC         | lea eax,dword ptr ss:[ebp-0x4]                     |
004E4C8F         | B9 01000000     | mov ecx,0x1                                        |
004E4C94         | 8B15 F44B4E00   | mov edx,dword ptr ds:[0x4E4BF4]                    | edx:"l;p"
004E4C9A         | E8 6D44F2FF     | call 月に寄りそう乙女の作法22.40910C                          | Dynarraysetlength
004E4C9F         | 83C4 04         | add esp,0x4                                        |
004E4CA2         | 8B45 F0         | mov eax,dword ptr ss:[ebp-0x10]                    |
004E4CA5         | 8BD6            | mov edx,esi                                        | edx:"l;p"
004E4CA7         | E8 F82CF2FF     | call 月に寄りそう乙女の作法22.4079A4                          |
004E4CAC         | 8BCE            | mov ecx,esi                                        |
004E4CAE         | 03C9            | add ecx,ecx                                        |
004E4CB0         | 8B55 FC         | mov edx,dword ptr ss:[ebp-0x4]                     |
004E4CB3         | 8B45 F8         | mov eax,dword ptr ss:[ebp-0x8]                     |
004E4CB6         | 8B38            | mov edi,dword ptr ds:[eax]                         | edi:"0yC"
004E4CB8         | FF57 0C         | call dword ptr ds:[edi+0xC]                        | 读取文件
004E4CBB         | 8BC6            | mov eax,esi                                        | 文件名解密开始
004E4CBD         | 35 133E0000     | xor eax,0x3E13                                     | 这里len异或了3e13
004E4CC2         | 33D8            | xor ebx,eax                                        | 这里异或了之前算出的Key
004E4CC4         | 8BC6            | mov eax,esi                                        |
004E4CC6         | F7EE            | imul esi                                           | eax=pow(esi,2)
004E4CC8         | 33D8            | xor ebx,eax                                        | 继续异或
004E4CCA         | 895D EC         | mov dword ptr ss:[ebp-0x14],ebx                    |
004E4CCD         | 8165 EC FFFF000 | and dword ptr ss:[ebp-0x14],0xFFFF                 |
004E4CD4         | 8B5D EC         | mov ebx,dword ptr ss:[ebp-0x14]                    |
004E4CD7         | 8B7D FC         | mov edi,dword ptr ss:[ebp-0x4]                     |
004E4CDA         | 8B45 F0         | mov eax,dword ptr ss:[ebp-0x10]                    |
004E4CDD         | E8 AA33F2FF     | call 月に寄りそう乙女の作法22.40808C                          |
004E4CE2         | 8945 E8         | mov dword ptr ss:[ebp-0x18],eax                    |
004E4CE5         | 8BC6            | mov eax,esi                                        |
004E4CE7         | 48              | dec eax                                            |
004E4CE8         | 85C0            | test eax,eax                                       |
004E4CEA         | 7C 2B           | jl 月に寄りそう乙女の作法22.4E4D17                            |
004E4CEC         | 40              | inc eax                                            |
004E4CED         | 33D2            | xor edx,edx                                        | edx:"l;p"
004E4CEF         | C1E3 03         | shl ebx,0x3                                        | 解密循环 ebx初值为刚刚算出的key
004E4CF2         | 8D0C1A          | lea ecx,dword ptr ds:[edx+ebx]                     | ecx = edx+ebx
004E4CF5         | 034D EC         | add ecx,dword ptr ss:[ebp-0x14]                    | ecx = ecx+key
004E4CF8         | 81E1 FFFF0000   | and ecx,0xFFFF                                     | ecx = ecx & 0xFFFF
004E4CFE         | 8BD9            | mov ebx,ecx                                        | ebx = ecx
004E4D00         | 0FB70F          | movzx ecx,word ptr ds:[edi]                        | ecx = (WORD)文件名数据
004E4D03         | 66:33CB         | xor cx,bx                                          | result = cx ^ bx
004E4D06         | 8B75 E8         | mov esi,dword ptr ss:[ebp-0x18]                    |
004E4D09         | 66:890E         | mov word ptr ds:[esi],cx                           |
004E4D0C         | 83C7 02         | add edi,0x2                                        | edi:"0yC"
004E4D0F         | 8345 E8 02      | add dword ptr ss:[ebp-0x18],0x2                    |
004E4D13         | 42              | inc edx                                            | edx为循环次数
004E4D14         | 48              | dec eax                                            |
004E4D15         | 75 D8           | jne 月に寄りそう乙女の作法22.4E4CEF                           |
004E4D17         | 33C0            | xor eax,eax                                        |
004E4D19         | 5A              | pop edx                                            | edx:"l;p"
004E4D1A         | 59              | pop ecx                                            |
004E4D1B         | 59              | pop ecx                                            |
004E4D1C         | 64:8910         | mov dword ptr fs:[eax],edx                         | eax:"^??~8", edx:"l;p"
004E4D1F         | 68 3A4D4E00     | push 月に寄りそう乙女の作法22.4E4D3A                          | Arg1 = "_^[嬪]?"
004E4D24         | 8D45 FC         | lea eax,dword ptr ss:[ebp-0x4]                     |
004E4D27         | 8B15 F44B4E00   | mov edx,dword ptr ds:[0x4E4BF4]                    | edx:"l;p"
004E4D2D         | E8 FA44F2FF     | call 月に寄りそう乙女の作法22.40922C                          | sub_40922C
004E4D32         | C3              | ret                                                |
```

![img](万华镜逆向(初试)/images/image-31.png)
![img](万华镜逆向(初试)/images/image-32.png)

```c++
struct FileEntry
{
        QWORD offset; //老规矩写代码要写成两个int
    DWORD size;
    DWORD dencrypted_size;
    DWORD isCompressed;
    DWORD unkown1; 
    DWORD unkown2;
};
```

![img](万华镜逆向(初试)/images/image-33.png)
![img](万华镜逆向(初试)/images/image-34.png)
![img](万华镜逆向(初试)/images/image-35.png)
![img](万华镜逆向(初试)/images/image-36.png)

```c++
004ECE7C         | 55              | push ebp                                           |
004ECE7D         | 8BEC            | mov ebp,esp                                        |
004ECE7F         | 83C4 F8         | add esp,0xFFFFFFF8                                 |
004ECE82         | 53              | push ebx                                           |
004ECE83         | 56              | push esi                                           |
004ECE84         | 57              | push edi                                           | edi:"0yC"
004ECE85         | 8955 F8         | mov dword ptr ss:[ebp-0x8],edx                     |
004ECE88         | 8945 FC         | mov dword ptr ss:[ebp-0x4],eax                     |
004ECE8B         | BB 32F58500     | mov ebx,0x85F532                                   | 这两个值之后会用到
004ECE90         | BE 41F63300     | mov esi,0x33F641                                   |
004ECE95         | 8B45 08         | mov eax,dword ptr ss:[ebp+0x8]                     |
004ECE98         | 8B40 08         | mov eax,dword ptr ds:[eax+0x8]                     |
004ECE9B         | 85C0            | test eax,eax                                       |
004ECE9D         | 74 1C           | je 月に寄りそう乙女の作法22.4ECEBB                            |
004ECE9F         | 8BD0            | mov edx,eax                                        | edx:"l;p"
004ECEA1         | 83EA 0A         | sub edx,0xA                                        | edx:"l;p"
004ECEA4         | 66:833A 02      | cmp word ptr ds:[edx],0x2                          | edx:"l;p"
004ECEA8         | 74 11           | je 月に寄りそう乙女の作法22.4ECEBB                            |
004ECEAA         | 8B45 08         | mov eax,dword ptr ss:[ebp+0x8]                     |
004ECEAD         | 8B50 08         | mov edx,dword ptr ds:[eax+0x8]                     | edx:"l;p"
004ECEB0         | 8B45 08         | mov eax,dword ptr ss:[ebp+0x8]                     |
004ECEB3         | 83C0 08         | add eax,0x8                                        |
004ECEB6         | E8 F59CF1FF     | call 月に寄りそう乙女の作法22.406BB0                          |
004ECEBB         | 85C0            | test eax,eax                                       |
004ECEBD         | 74 05           | je 月に寄りそう乙女の作法22.4ECEC4                            |
004ECEBF         | 83E8 04         | sub eax,0x4                                        |
004ECEC2         | 8B00            | mov eax,dword ptr ds:[eax]                         | eax=文件名字符数
004ECEC4         | 8BD0            | mov edx,eax                                        | edx:"l;p"
004ECEC6         | 4A              | dec edx                                            | edx:"l;p"
004ECEC7         | 85D2            | test edx,edx                                       | edx:"l;p"
004ECEC9         | 7C 20           | jl 月に寄りそう乙女の作法22.4ECEEB                            |
004ECECB         | 42              | inc edx                                            | edx:"l;p"
004ECECC         | 33C0            | xor eax,eax                                        |
004ECECE         | 8D48 01         | lea ecx,dword ptr ds:[eax+0x1]                     | 循环开始
004ECED1         | 8B7D 08         | mov edi,dword ptr ss:[ebp+0x8]                     |
004ECED4         | 8B7F 08         | mov edi,dword ptr ds:[edi+0x8]                     | edi:"0yC"
004ECED7         | 0FB77C4F FE     | movzx edi,word ptr ds:[edi+ecx*2-0x2]              | 取文件名的每个字符
004ECEDC         | 8BC8            | mov ecx,eax                                        | eax为循环次数
004ECEDE         | 83E1 07         | and ecx,0x7                                        | ecx=eax & 7
004ECEE1         | D3E7            | shl edi,cl                                         | edi为文件名word字符
004ECEE3         | 03DF            | add ebx,edi                                        | ebx=ebx+(edi << cl)
004ECEE5         | 33F3            | xor esi,ebx                                        | esi^=ebx
004ECEE7         | 40              | inc eax                                            | eax++
004ECEE8         | 4A              | dec edx                                            | edx--
004ECEE9         | 75 E3           | jne 月に寄りそう乙女の作法22.4ECECE                           | 使用文件名算出了一个（两个？esi ebx）hash
004ECEEB         | 8B45 08         | mov eax,dword ptr ss:[ebp+0x8]                     |
004ECEEE         | 8B40 FC         | mov eax,dword ptr ds:[eax-0x4]                     | eax=数据大小
004ECEF1         | 35 DC328F00     | xor eax,0x8F32DC                                   |
004ECEF6         | 33C3            | xor eax,ebx                                        |
004ECEF8         | 03C3            | add eax,ebx                                        | eax=eax^ebx^0x8F32DC+ebx
004ECEFA         | 8B55 08         | mov edx,dword ptr ss:[ebp+0x8]                     |
004ECEFD         | 0342 FC         | add eax,dword ptr ds:[edx-0x4]                     | eax=eax+数据大小
004ECF00         | 8B55 08         | mov edx,dword ptr ss:[ebp+0x8]                     |
004ECF03         | 8B52 FC         | mov edx,dword ptr ds:[edx-0x4]                     | edx=数据大小
004ECF06         | 81E2 FFFFFF00   | and edx,0xFFFFFF                                   | edx=edx & 0xFFFFFF
004ECF0C         | 8BCA            | mov ecx,edx                                        | edx:"l;p"
004ECF0E         | 03D2            | add edx,edx                                        | edx:"l;p"
004ECF10         | 03D2            | add edx,edx                                        | edx:"l;p"
004ECF12         | 03D2            | add edx,edx                                        | edx=edx*8
004ECF14         | 2BD1            | sub edx,ecx                                        | edx=edx-数据大小
004ECF16         | 03C2            | add eax,edx                                        | eax+=edx
004ECF18         | 8B55 08         | mov edx,dword ptr ss:[ebp+0x8]                     |
004ECF1B         | 3342 0C         | xor eax,dword ptr ds:[edx+0xC]                     | 异或了一个奇怪的值 //这个奇怪的值就是之前最早算的hash
004ECF1E         | 03F0            | add esi,eax                                        |
004ECF20         | 8BC6            | mov eax,esi                                        |
004ECF22         | 25 FFFFFF00     | and eax,0xFFFFFF                                   | eax=(eax+esi)&0xFFFFFF
004ECF27         | 8D04C0          | lea eax,dword ptr ds:[eax+eax*8]                   | eax=eax*9
004ECF2A         | 8BC8            | mov ecx,eax                                        |
004ECF2C         | 8B55 F8         | mov edx,dword ptr ss:[ebp-0x8]                     | 循环次数
004ECF2F         | 8B45 FC         | mov eax,dword ptr ss:[ebp-0x4]                     | 输出的缓冲区
004ECF32         | E8 09FFFFFF     | call 月に寄りそう乙女の作法22.4ECE40                          |
004ECF37         | 5F              | pop edi                                            | edi:"0yC"
004ECF38         | 5E              | pop esi                                            |
004ECF39         | 5B              | pop ebx                                            |
004ECF3A         | 59              | pop ecx                                            |
004ECF3B         | 59              | pop ecx                                            |
004ECF3C         | 5D              | pop ebp                                            |
004ECF3D         | C3              | ret                                                |
```

写成c++代码

```c++
DWORD* dencrypt3_hash(int hashlen,int datalen,void* filename,int character_count,DWORD hash)
{
    DWORD key1 = 0x85F532; //ebx
    DWORD key2 = 0x33F641; //esi
    WORD* character = (WORD*)filename;
    for (size_t i = 0; i < character_count; i++)
    {
        key1 = key1 + (*character << (i & 7));
        key2 ^= key1;
        character++;
    }
    DWORD key3 = (datalen ^ key1 ^ 0x8F32DC) + key1 + datalen; //eax
    DWORD key4 = ((datalen & 0xFFFFFF) << 3) - datalen; //edx
    key3 += key4;
    key3 ^= hash;
    key3 = ((key3 + key2) & 0xFFFFFF) * 9;
    //第二个计算函数
    unsigned long long rax = key3;
    DWORD* result = new DWORD[hashlen];
    for (size_t i = 0; i < hashlen; i++)
    {
        rax = (unsigned long long)(rax ^ 0x8DF21431u) * (unsigned long long)0x8DF21431u;
        rax = ((rax & 0xFFFFFFFF00000000) >> 32) + (rax & 0xFFFFFFFF);
        rax = rax & 0xFFFFFFFF;
        result[i] = rax;
    }
  
  
    return result;
}
```

最后是dencrypt3
关键的代码是这部分

```
004ED02B         | 59              | pop ecx                                            |
004ED02C         | 8B45 08         | mov eax,dword ptr ss:[ebp+0x8]                     |
004ED02F         | 8B40 FC         | mov eax,dword ptr ds:[eax-0x4]                     | [eax-4]:L"甄Cа"
004ED032         | C1E8 03         | shr eax,0x3                                        | eax=数据大小>>3
004ED035         | 8945 FC         | mov dword ptr ss:[ebp-0x4],eax                     |
004ED038         | 837D FC 00      | cmp dword ptr ss:[ebp-0x4],0x0                     | 数据大小 >> 3 等于0就结束
004ED03C         | 74 73           | je 月に寄りそう乙女の作法22.4ED0B1                            |
004ED03E         | 8B45 08         | mov eax,dword ptr ss:[ebp+0x8]                     |
004ED041         | 8B40 F8         | mov eax,dword ptr ds:[eax-0x8]                     |
004ED044         | 8945 F4         | mov dword ptr ss:[ebp-0xC],eax                     |
004ED047         | 8D85 F0FEFFFF   | lea eax,dword ptr ss:[ebp-0x110]                   | eax = 刚刚算出hash的指针
004ED04D         | 8945 F0         | mov dword ptr ss:[ebp-0x10],eax                    |
004ED050         | 8B85 24FFFFFF   | mov eax,dword ptr ss:[ebp-0xDC]                    | 相当于取了算出的hash指针+0x34的DWORD key1
004ED056         | 83E0 0F         | and eax,0xF                                        |
004ED059         | 03C0            | add eax,eax                                        |
004ED05B         | 03C0            | add eax,eax                                        |
004ED05D         | 03C0            | add eax,eax                                        | key1 = (val & 0xF) << 3
004ED05F         | 8945 F8         | mov dword ptr ss:[ebp-0x8],eax                     |
004ED062         | 50              | push eax                                           |
004ED063         | 53              | push ebx                                           |
004ED064         | 51              | push ecx                                           |
004ED065         | 52              | push edx                                           | edx:"l;p"
004ED066         | 56              | push esi                                           |
004ED067         | 57              | push edi                                           | edi:"0yC"
004ED068         | 8B4D FC         | mov ecx,dword ptr ss:[ebp-0x4]                     | ecx=数据大小>>3
004ED06B         | 8B55 F8         | mov edx,dword ptr ss:[ebp-0x8]                     | edx = key1
004ED06E         | 8B7D F4         | mov edi,dword ptr ss:[ebp-0xC]                     | edi指向了要解密的数据
004ED071         | 8B75 F0         | mov esi,dword ptr ss:[ebp-0x10]                    | esi指向之前算出的hash
004ED074         | 0F6F7E 18       | movq mm7,qword ptr ds:[esi+0x18]                   | mm7 = *(QWORD*)(hash+0x18)
004ED078         | 8D0432          | lea eax,dword ptr ds:[edx+esi]                     |
004ED07B         | 0F6F30          | movq mm6,qword ptr ds:[eax]                        | mm6 = *(QWORD*)(hash+key1)
004ED07E         | 0FEFFE          | pxor mm7,mm6                                       | mm7 ^= mm6
004ED081         | 0FFEFE          | paddd mm7,mm6                                      |
004ED084         | 0F6F07          | movq mm0,qword ptr ds:[edi]                        | mm0 = data
004ED087         | 0FEFC7          | pxor mm0,mm7                                       | mm0 ^= mm7
004ED08A         | 0F6FC8          | movq mm1,mm0                                       | mm1 = mm0
004ED08D         | 0F7F07          | movq qword ptr ds:[edi],mm0                        | 解密3写入数据
004ED090         | 0FFCF9          | paddb mm7,mm1                                      |
004ED093         | 0FEFF9          | pxor mm7,mm1                                       |
004ED096         | 0F72F7 01       | pslld mm7,0x1                                      |
004ED09A         | 0FFDF9          | paddw mm7,mm1                                      |
004ED09D         | 83C7 08         | add edi,0x8                                        | edi:"0yC"
004ED0A0         | 83C2 08         | add edx,0x8                                        | edx:"l;p"
004ED0A3         | 83E2 7F         | and edx,0x7F                                       | key1 = (key1 + 8)& 0x7F
004ED0A6         | 49              | dec ecx                                            |
004ED0A7         | 75 CF           | jne 月に寄りそう乙女の作法22.4ED078                           |
```

写成c++

```c++
void dencrypt3(void* data,int len, void* filekey)
{
    //0x34相当于4字节数据+0xD
    DWORD key1 = (*((DWORD*)filekey + 0xD) & 0xF) << 3;
    BYTE* datapos = (BYTE*)data, * fkey = (BYTE*)filekey;
    __m64 mm7 = *((__m64*)filekey + 0x3); //这里0x3相当于BYTE的0x18
    __m64 mm6, mm0, mm1;
    for (size_t i = 0; i < len >>3; i++)
    {
        mm6 = *(__m64*)(fkey + key1);
        mm7 = _m_pxor(mm7, mm6);
        mm7 = _m_paddd(mm7, mm6);
        mm0 = *(__m64*)datapos;
        mm0 = _m_pxor(mm0, mm7);
        mm1 = mm0;
        *(__m64*)datapos = mm0;
        mm7 = _m_paddb(mm7, mm1);
        mm7 = _m_pxor(mm7, mm1);
        mm7 = _m_pslldi(mm7, 0x1);
        mm7 = _m_paddw(mm7, mm1);
        datapos += 8;
        key1 = (key1 + 8) & 0x7F;
    }
    _m_empty();
    return;
}
```

![img](万华镜逆向(初试)/images/image-37.png)
![img](万华镜逆向(初试)/images/image-38.png)
![img](万华镜逆向(初试)/images/image-39.png)
![img](万华镜逆向(初试)/images/image-40.png)
![img](万华镜逆向(初试)/images/image-41.png)
![img](万华镜逆向(初试)/images/image-42.png)
![img](万华镜逆向(初试)/images/image-43.png)

```c++
BYTE* dencypt4_keyfilehash(void* data,int len)
{
    int* keyfilehash = new int[0x100];
    int* keyfilehash_pos = keyfilehash;
    //keyhash初始数据的计算
    for (size_t i = 0; i < 0x100; i++)
    {
        if (i % 3 ==0)
        {
            *keyfilehash_pos = (i + 3u) * (i + 7u);
        }
        else
        {
            *keyfilehash_pos = -(i + 3u) * (i + 7u);
        }
        keyfilehash_pos++;
    }
    int key1 = *(BYTE*)((BYTE*)data + 0x31);
    key1 = (key1 % 0x49) + 0x80;
    int key2 = *(BYTE*)((BYTE*)data + 0x1E + 0x31);
    key2 = (key2 % 7) + 7;
    BYTE* keyfilehash_pos_byte = (BYTE*)keyfilehash;
    for (size_t i = 0; i < 0x400; i++)
    {
        key1 = (key1 + key2) % len;
        *keyfilehash_pos_byte ^= *(BYTE*)((BYTE*)data + key1);
        keyfilehash_pos_byte++;
    }
    return (BYTE*)keyfilehash;
}
```

![img](万华镜逆向(初试)/images/image-44.png)

```c++
#include <iostream>
#include <Windows.h>
#include <string>
#include <mmintrin.h>
#include <stack>
using namespace std;
struct FilePackVer
{
    char sign[0x10];
    DWORD filecount;
    int entry_low;
    int entry_high;
};
struct HashData
{
    char sign[0x20];
    DWORD HashVerSize;
    char data[0x100];
    DWORD Unkown;
    char Blank[0x2F8];
    FilePackVer fpacker;
};
struct Dencrypt2DataHead
{
    DWORD sign;
    DWORD isWordType;
    DWORD size;
};
struct Dencrypt2DataOutput
{
    BYTE* data;
    DWORD len;
};
struct FileEntry
{
    DWORD offset_low;
    DWORD offset_hight;
    DWORD size;
    DWORD dencrypted_size;
    DWORD isCompressed;
    DWORD EncryptType; // 0未加密 1第一种加密算法 2为第二种加密算法
    DWORD hash;
};
DWORD Tohash(void* data, int len)
{
    if (len < 8)
    {
        return 0;
    }
    //准备工作
    __m64 mm0 = _mm_cvtsi32_si64(0);
    __m64 mm1;
    __m64 mm2 = _mm_cvtsi32_si64(0);
    DWORD key = 0xA35793A7;
    __m64 mm3 = _mm_cvtsi32_si64(key);
     mm3 = _m_punpckldq(mm3, mm3);
     __m64* pdata=(__m64*)data;
    //开始循环计算hash
    for (size_t i = 0; i < (len >> 3); i++)
    {
        mm1 = *pdata;
        pdata++;
        mm2 = _m_paddw(mm2, mm3);
        mm1 = _m_pxor(mm1, mm2);
        mm0 = _m_paddw(mm0, mm1);
        mm1 = mm0;
        mm0 = _m_pslldi(mm0, 3);
        mm1 = _m_psrldi(mm1, 0x1D);
        mm0 = _m_por(mm1, mm0);
    }
    mm1 = _m_psrlqi(mm0, 32);
    DWORD result = _mm_cvtsi64_si32(_m_pmaddwd(mm0, mm1));
    _m_empty();//复位浮点寄存器
    return result;
}
void dencrypt(void* data,unsigned int len, DWORD hash)
{
    if (len >> 3 == 0)
    {
        return;
    }
    //准备工作
    DWORD key1 = 0xA73C5F9D;
    DWORD key2 = 0xCE24F523;
    DWORD key3 = (len + hash)^ 0xFEC9753E;
    __m64 mm7 = _mm_cvtsi32_si64(key1);
    mm7 = _m_punpckldq(mm7, mm7);
    __m64 mm6 = _mm_cvtsi32_si64(key2);
    mm6 = _m_punpckldq(mm6, mm6);
    __m64 mm5 = _mm_cvtsi32_si64(key3);
    mm5 = _m_punpckldq(mm5, mm5);
    __m64* datapos = (__m64*)data;
    __m64 mm0;
    for (size_t i = 0; i < len >> 3; i++)
    {
        mm7 = _m_paddd(mm7, mm6);
        mm7 = _m_pxor(mm7, mm5);
        mm0 = *datapos;
        mm0 = _m_pxor(mm0, mm7);
        mm5 = mm0;
        *datapos = mm0;
        datapos++;
    }
    _m_empty();//复位浮点寄存器
    return;
}
Dencrypt2DataOutput* dencrypt2(void* data, unsigned int len,unsigned int dencrypted_len, DWORD hash)
{
    char Sampletable[0x100],table[0x100],other[0x100];
    for (size_t i = 0; i < 0x100; i++)
    {
        Sampletable[i] = i;
    }
    Dencrypt2DataHead* head = (Dencrypt2DataHead*)data;
    //对比开头是否为0xFF425031
    if (head->sign != 0xFF435031)
    {
        cout << "数据不符合解码条件" << endl;
        return nullptr;
    }
    if (head->size> 0x20000000u)
    {
        cout << "数据量大于0x20000000" << endl;
        return nullptr;
    }
  
    Dencrypt2DataOutput* Output = new Dencrypt2DataOutput();
    Output->len = dencrypted_len;
    Output->data = new BYTE[dencrypted_len + 1];
    BYTE* outputbuff = Output->data;
  
    BYTE* datapos = (BYTE*)data + sizeof(Dencrypt2DataHead);
    BYTE* data_start = datapos;
    BYTE* data_end = (BYTE*)data + len;
    BYTE chr;
    int t_pos;
    int size;
    while (data_start < data_end)
    {
        chr = *data_start;
        datapos = data_start + 1;
        memcpy(table, Sampletable, 0x100);
        t_pos = 0;
        //建表循环
        while (1)
        {
            if (chr > 0x7Fu)
            {
                t_pos += chr - 127;
                chr = 0;
            }
            if (t_pos > 0xFF)
            {
                break;
            }
  
            for (size_t i = 0; i < chr + 1; i++)
            {
                table[t_pos] = *datapos++;
                if (t_pos != (unsigned __int8)table[t_pos])
                {
                    other[t_pos] = *datapos++;
                }
  
                ++t_pos;
            }
            if (t_pos > 0xFF)
            {
                break;
            }
            chr = *datapos++;
        }
        //数据类型判断
        if ((head->isWordType & 1) == 1)
        {
            size = *(WORD*)datapos;
            data_start = (datapos + 2);
        }
        else
        {
            size = *(DWORD*)datapos;
            data_start = (datapos + 4);
        }
        //解密循环
        stack<BYTE> stack;
        while (1)
        {
            BYTE result;
            if (stack.size())
            {
                result = stack.top();
                stack.pop();
            }
            else
            {
                if (!size)
                {
                    break;
                }
                size--;
                result = *data_start;
                data_start++;
            }
            if (result == (BYTE)table[result])
            {
                *outputbuff = result;
                outputbuff++;
            }
            else
            {
                stack.push(other[result]);
                stack.push(table[result]);
            }
        }
    }
    return Output;
}
void DencryptFileName(void* data,int character_count,DWORD hash)
{
    int key = ((hash >> 0x10) & 0xFFFF) ^ hash;
    key = character_count ^ 0x3E13 ^ key ^ (character_count * character_count);
    DWORD ebx = key;
    DWORD ecx;
    WORD* datapos = (WORD*)data;
    for (size_t i = 0; i < character_count; i++)
    {
        ebx = ebx << 3;
        ecx = (ebx + i + key) & 0xFFFF;
        ebx = ecx;
        *datapos = (*datapos ^ ebx) & 0xFFFF;
        datapos++;
    }
}
DWORD* dencrypt3_hash(int hashlen,int datalen,void* filename,int character_count,DWORD hash)
{
    DWORD key1 = 0x85F532; //ebx
    DWORD key2 = 0x33F641; //esi
    WORD* character = (WORD*)filename;
    for (size_t i = 0; i < character_count; i++)
    {
        key1 = key1 + (*character << (i & 7));
        key2 ^= key1;
        character++;
    }
    DWORD key3 = (datalen ^ key1 ^ 0x8F32DC) + key1 + datalen; //eax
    DWORD key4 = ((datalen & 0xFFFFFF) << 3) - datalen; //edx
    key3 += key4;
    key3 ^= hash;
    key3 = ((key3 + key2) & 0xFFFFFF) * 9;
    //第二个计算函数
    unsigned long long rax = key3;
    DWORD* result = new DWORD[hashlen];
    for (size_t i = 0; i < hashlen; i++)
    {
        rax = (unsigned long long)(rax ^ 0x8DF21431u) * (unsigned long long)0x8DF21431u;
        rax = ((rax & 0xFFFFFFFF00000000) >> 32) + (rax & 0xFFFFFFFF);
        rax = rax & 0xFFFFFFFF;
        result[i] = rax;
    }
  
  
    return result;
}
void dencrypt3(void* data,int len, void* filekey)
{
    //0x34相当于4字节数据+0xD
    DWORD key1 = (*((DWORD*)filekey + 0xD) & 0xF) << 3;
    BYTE* datapos = (BYTE*)data, * fkey = (BYTE*)filekey;
    __m64 mm7 = *((__m64*)filekey + 0x3); //这里0x3相当于BYTE的0x18
    __m64 mm6, mm0, mm1;
    for (size_t i = 0; i < len >>3; i++)
    {
        mm6 = *(__m64*)(fkey + key1);
        mm7 = _m_pxor(mm7, mm6);
        mm7 = _m_paddd(mm7, mm6);
        mm0 = *(__m64*)datapos;
        mm0 = _m_pxor(mm0, mm7);
        mm1 = mm0;
        *(__m64*)datapos = mm0;
        mm7 = _m_paddb(mm7, mm1);
        mm7 = _m_pxor(mm7, mm1);
        mm7 = _m_pslldi(mm7, 0x1);
        mm7 = _m_paddw(mm7, mm1);
        datapos += 8;
        key1 = (key1 + 8) & 0x7F;
    }
    _m_empty();
    return;
}
BYTE* dencypt4_keyfilehash(void* data,int len)
{
    int* keyfilehash = new int[0x100];
    int* keyfilehash_pos = keyfilehash;
    //keyhash初始数据的计算
    for (size_t i = 0; i < 0x100; i++)
    {
        if (i % 3 ==0)
        {
            *keyfilehash_pos = (i + 3u) * (i + 7u);
        }
        else
        {
            *keyfilehash_pos = -(i + 3u) * (i + 7u);
        }
        keyfilehash_pos++;
    }
    int key1 = *(BYTE*)((BYTE*)data + 0x31);
    key1 = (key1 % 0x49) + 0x80;
    int key2 = *(BYTE*)((BYTE*)data + 0x1E + 0x31);
    key2 = (key2 % 7) + 7;
    BYTE* keyfilehash_pos_byte = (BYTE*)keyfilehash;
    for (size_t i = 0; i < 0x400; i++)
    {
        key1 = (key1 + key2) % len;
        *keyfilehash_pos_byte ^= *(BYTE*)((BYTE*)data + key1);
        keyfilehash_pos_byte++;
    }
    return (BYTE*)keyfilehash;
}
DWORD* dencrypt4_hash(int hashlen, int datalen, void* filename, int character_count, DWORD hash)
{
    DWORD key1 = 0x86F7E2; //ebx
    DWORD key2 = 0x4437F1; //esi
    WORD* character = (WORD*)filename;
    for (size_t i = 0; i < character_count; i++)
    {
        key1 = key1 + (*character << (i & 7));
        key2 ^= key1;
        character++;
    }
    DWORD key3 = (datalen ^ key1 ^ 0x56E213) + key1 + datalen; //eax
    int key4 = (datalen & 0xFFFFFF) * 0xD; //edx
    key3 += key4;
    key3 ^= hash;
    key3 = ((key3 + key2) & 0xFFFFFF) * 0xD;
    //第二个计算函数
    unsigned long long rax = key3;
    DWORD* result = new DWORD[hashlen];
    for (size_t i = 0; i < hashlen; i++)
    {
        rax = (unsigned long long)(rax ^ 0x8A77F473u) * (unsigned long long)0x8A77F473u;
        rax = ((rax & 0xFFFFFFFF00000000) >> 32) + (rax & 0xFFFFFFFF);
        rax = rax & 0xFFFFFFFF;
        result[i] = rax;
    }
  
  
    return result;
}
void dencrypt4(void* data, int len, void* filekey,void* keyfilehash)
{
    //0x20相当于4字节数据+0x8
    DWORD key1 = (*((DWORD*)filekey + 0x8) & 0xD) << 3;
    BYTE* datapos = (BYTE*)data, * fkey = (BYTE*)filekey,* keyfilekey = (BYTE*)keyfilehash;
    __m64 mm7 = *((__m64*)filekey + 0x3); //这里0x3相当于BYTE的0x18
    __m64 mm6, mm0, mm1,mm5;
    for (size_t i = 0; i < len >> 3; i++)
    {
        mm6 = *(__m64*)(fkey + ((key1 & 0xF) << 3));
        mm5 = *(__m64*)(keyfilekey + ((key1 & 0x7F) << 3));
        mm6 = _m_pxor(mm6, mm5);
        mm7 = _m_pxor(mm7, mm6);
        mm7 = _m_paddd(mm7, mm6);
        mm0 = *(__m64*)datapos;
        mm0 = _m_pxor(mm0, mm7);
        mm1 = mm0;
        *(__m64*)datapos = mm0;
        mm7 = _m_paddb(mm7, mm1);
        mm7 = _m_pxor(mm7, mm1);
        mm7 = _m_pslldi(mm7, 0x1);
        mm7 = _m_paddw(mm7, mm1);
        datapos += 8;
        key1 = (key1 + 1) & 0x7F;
    }
    _m_empty();
    return;
}
FILE* WideChar_CreateFile(const wchar_t* filename)
{
    wchar_t* pos = (wchar_t*)filename;
    while (1)
    {
        pos = wcschr(pos, '\\');
        if (pos == nullptr)
        {
            break;
        }
        wchar_t* dir = new wchar_t[pos - filename + 1]();
        wcsncpy(dir, filename, pos - filename);
        _wmkdir(dir);
        pos++;
        delete dir;
    }
    FILE* hfile = _wfopen(filename, L"wb");
    return hfile;
}
int main()
{
    string filename;
    cin >> filename;
    FILE* hfile;
    hfile = fopen(filename.c_str(), "rb");
    //获取文件大小,支持大于4GB文件
    _fseeki64(hfile, 0, 2);
    fpos_t file_size = _ftelli64(hfile);
    //读取filepack头
    _fseeki64(hfile, file_size - 0x1C, 0);
    FilePackVer* filepacker = new FilePackVer();
    fread(filepacker, 0x1C,1 , hfile);
    if (string(filepacker->sign) != "FilePackVer3.1\x00\x00")
    {
        cout << "FilePackVer签名验证失败" << endl;
        return 0;
    }
    //读取HashData
    HashData *hashdat = new HashData();
    _fseeki64(hfile,file_size-0x440,0);
    fread(hashdat,1,0x440,hfile);
    //数据的设置
    if (hashdat->Unkown > 8 || hashdat->Unkown < 0)
    {
        hashdat->Unkown = 0;
    }
    DWORD hash = Tohash(&hashdat->data,0x100) & 0x0FFFFFFF;
    //HashVer里的数据对解包并不重要 直接略过不按照程序一样去读取了
  
  
    /////////////////////////////////
    //解码签名
    dencrypt(&hashdat->sign, 0x20, hash);
    if (strncmp(hashdat->sign,"8hr48uky,8ugi8ewra4g8d5vbf5hb5s6",0x20))
    {
        cout << "HashData签名验证失败" << endl;
        return 0;
    }
    //开始解密文件
     
    DWORD64 entry = ((long long)filepacker->entry_high << 32) + (long long)filepacker->entry_low;
    BYTE* keyfilehash = nullptr;
    for (size_t i = 0; i < filepacker->filecount; i++)
    {
        _fseeki64(hfile, entry, 0);
        WORD character_count;
        fread(&character_count, 2, 1, hfile);
        wchar_t* name = new wchar_t[character_count + 1]();
        //因为UTF16字节数是ASCII的两倍，所以要乘2
        fread(name, 1, 2 * character_count, hfile);
        //解密文件名
        DencryptFileName(name, character_count, hash);
        FileEntry *fentry = new FileEntry();
        fread(fentry, 1, 0x1C, hfile);
        entry = _ftelli64(hfile);
        //文件名hash校检 不重要 略过
  
        //文件读取
        char* filedata = new char[fentry->size];
        _fseeki64(hfile, ((long long)fentry->offset_hight << 32) + (long long)fentry->offset_low, 0);
        fread(filedata, fentry->size, 1, hfile);
  
        //解密文件
        DWORD* filehash = nullptr;
        if (fentry->EncryptType == 1)
        {
            filehash = dencrypt3_hash(0x40, fentry->size, name, character_count, hash);
            dencrypt3(filedata, fentry->size, filehash);
            if (wcsncmp(name, L"pack_keyfile_kfueheish15538fa9or.key", character_count) == 0)
            {
                keyfilehash = dencypt4_keyfilehash(filedata, fentry->size);
            }
        }
        else if(fentry->EncryptType == 2)
        {
            filehash = dencrypt4_hash(0x40, fentry->size, name, character_count, hash);
            dencrypt4(filedata, fentry->size, filehash, keyfilehash);
        }
        Dencrypt2DataOutput* Output = nullptr;
        if (fentry->isCompressed)
        {
            Output = dencrypt2(filedata, fentry->size, fentry->dencrypted_size, hash);
        }
        else
        {
            Output = new Dencrypt2DataOutput();
            Output->data = (BYTE*)filedata;
            Output->len = fentry->dencrypted_size;
        }
        //保存文件
        wstring filename = wstring(name);
        filename = L"Extract\\" + filename;
        FILE* hOut = WideChar_CreateFile(filename.c_str());
        std::fwrite(Output->data, Output->len, 1, hOut);
        std::fclose(hOut);
        delete fentry, name, filedata, filehash, Output;
    }
  
    std::fclose(hfile);
}
```

# 实操复现

教程是从近月2入手的 跟着一步步分析

## 信息收集

近月2和万华镜系列的特征一模一样
主文件夹下的`GameData`中的`xxx.pack`文件就是关键

32位PE文件
用IDA翻string翻出来一些特征
![img](万华镜逆向(初试)/images/image-45.png)
其实这里的`8hr48uky,8ugi8ewra4g8d5vbf5hb5s6`就是验签的hash值
交叉引用很容易分析出这里的check
![img](万华镜逆向(初试)/images/image-46.png)

再通过find_crypt发现sha256 大致能想到引擎从`.pack`解出数据后作了check检查
大致信息就收集这么多

## x32dbg 动态调试

下面用x32dbg看 方便查看栈和寄存器的值以及对WinAPI下断点
发现入口地址与IDA给出的start地址一样

如果从入口点开始逆向分析的话工作量比较大 学习教程下API断点关注对文件的操作

### 设置条件断点

#### CreateFileW

通过API断点 或者搜索字符串定位到`74D6E570` 条件断点编辑如下
![img](万华镜逆向(初试)/images/image-47.png)

这里的`esp+4`的偏移可以很容易通过动调在栈中看到 然后采用utf16格式输出
暂停条件设置为0就只会记录日志而不会暂停 可以F9一遍后看日志来分析 再缩小返回

同理 按教程的输出设置`ReadFile` `SetFilePointer` 的条件断点

#### ReadFile

查看官方文档

```c
BOOL ReadFile(
  [in]                HANDLE       hFile,
  [out]               LPVOID       lpBuffer,
  [in]                DWORD        nNumberOfBytesToRead,
  [out, optional]     LPDWORD      lpNumberOfBytesRead,
  [in, out, optional] LPOVERLAPPED lpOverlapped
);
```

很容易看出 `esp+4 esp+8 esp+c`的结构
但是这里搜索遇到了直接搜不到的问题
解决方法是先断下`CreateFileW` 然后附近找到`jmp &ReadFile` 跟踪跳转
设置条件断点如下:
![img](万华镜逆向(初试)/images/image-52.png)


#### SetFilePointer

查看Windows官方文档

```c
DWORD SetFilePointer(
  [in]                HANDLE hFile,
  [in]                LONG   lDistanceToMove,
  [in, out, optional] PLONG  lpDistanceToMoveHigh,
  [in]                DWORD  dwMoveMethod
);
```

要注意这里的 高DWORD是 `PLONG`类型 即 `LONG`的指针 所以要`[[esp+c]]`
设置条件断点如下:


日志分析:
![img](万华镜逆向(初试)/images/image-49.png)

那么就可以按照教程的方法 在`CreateFileW`设置一个条件断点 当`Gamexxx`的时候断下来 就可以跟踪到`xxx.pack`的文件操作
但我设置后还是每个都断 好在文件不多 手动断到 `data0` 返回到用户领空
![img](万华镜逆向(初试)/images/image-50.png)
对应到IDA其实就是这块 FileOpen (IDA可以用G快速跳转地址)
![img](万华镜逆向(初试)/images/image-51.png)

当我们断到`data0`后 开启`ReadFile`的断点 来看读取了什么内容
发现日志输出
`读取文件   句柄:3AC   缓冲:19FCDB  字节数:1C`
回到用户领空
![img](万华镜逆向(初试)/images/image-53.png)
有个`FilePackVer3.0`的字样
注意前面的`00 E8 FC 19`  小端序转一下就是 `19FCE8`  指向的正好是 `Filexxx`字串结束后的地址

接下来继续调试 发现就开始计算hash了
首先判断`FilePackVer`的版本 然后进行对应的hash操作
IDA可以很直观的看到
![img](万华镜逆向(初试)/images/image-54.png)
进入`sub_4880c0`
![img](万华镜逆向(初试)/images/image-55.png)
从`LStrCmp`那里的比较往前看 `v17<-v18<-v4<-v1`
所以 `sub_483DA8`和`sub_48318C`都很关键

再前面的间接函数调用x32dbg动调可知就是 `FileRead` 而且读的是`data0.pack`的内容
而且在x32dbg动调的时候发现多出来一个 `data0.hash`
![img](万华镜逆向(初试)/images/image-56.png)

程序从`0019F880`开始读取了256数据后进入`sub_483DA8`
里面采用的`MMX指令集`
![img](万华镜逆向(初试)/images/image-57.png)

sub_483DA8

```c++
int __fastcall sub_483DA8(__m64 *a1, unsigned int a2)
{
  unsigned int v4; // ecx
  __m64 v5; // mm0
  __m64 v6; // mm2
  __m64 v7; // mm3
  __m64 v8; // mm3

  if ( a2 < 8 )
    return 0;
  v4 = a2 >> 3;
  v5.m64_u64 = 0i64;
  v6.m64_u64 = 0i64;
  v7 = _mm_cvtsi32_si64(0x3070307u);
  v8 = _m_punpckldq(v7, v7);
  do
  {
    v6 = _m_paddw(v6, v8);
    v5 = _m_paddw(v5, _m_pxor((__m64)a1->m64_u64, v6));
    ++a1;
    --v4;
  }
  while ( v4 );
  _m_empty();
  return _mm_cvtsi64_si32(_m_pxor(v5, _m_psrlqi(v5, 0x20u)));
}
```

返回后继续跟进 `sub_48318C`
走的是`if(a3)`的分支
`sub_48310C`

```c++
unsigned int __cdecl sub_48310C(int a1)
{
  unsigned int result; // eax
  int v2; // ecx
  __m64 *v3; // edx
  __m64 v4; // mm7
  __m64 v5; // mm7
  __m64 v6; // mm6
  __m64 v7; // mm6
  __m64 v8; // mm5
  __m64 v9; // mm5
  unsigned int v10; // [esp-4h] [ebp-10h]

  result = (*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 - 4)) ^ 0xFEC9753E;
  if ( *(_DWORD *)(a1 - 4) >> 3 )
  {
    v10 = *(_DWORD *)(a1 - 8);
    v2 = *(_DWORD *)(a1 - 4) >> 3;
    v3 = (__m64 *)v10;
    v4 = _mm_cvtsi32_si64(0xA73C5F9D);
    v5 = _m_punpckldq(v4, v4);
    v6 = _mm_cvtsi32_si64(0xCE24F523);
    v7 = _m_punpckldq(v6, v6);
    v8 = _mm_cvtsi32_si64((*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 - 4)) ^ 0xFEC9753E);
    v9 = _m_punpckldq(v8, v8);
    do
    {
      v5 = _m_pxor(_m_paddd(v5, v7), v9);
      v9 = _m_pxor((__m64)v3->m64_u64, v5);
      v3->m64_u64 = (unsigned __int64)v9;
      ++v3;
      --v2;
    }
    while ( v2 );
    _m_empty();
    result = v10;
  }
  return result;
}
```

这就很有感觉了
这里先跳过 ret后`eax:0019F85C` 存储的就是计算后的结果
![img](万华镜逆向(初试)/images/image-58.png)

验签完过后的一堆赋值操作最开始被我忽略掉了...
其实仔细看会发现是跟 `FilePack`的结构体有关!!!
![img](万华镜逆向(初试)/images/image-59.png)
分别取了三部分的四字节数据

其中出现了`cdq`指令:
IDA给出了定义 `EAX -> EDX:EAX (with sign)`
这是为了兼容64位寄存器的情况
这里把eax和edx合并了
![img](万华镜逆向(初试)/images/image-60.png)
结合eax的`14D`指向的是
![img](万华镜逆向(初试)/images/image-61.png)
可以猜测这个应该是结构体存储的一个跳转/入口地址


大致分析一下 `FilePack`结构体的结构

```c++
struct FilePack{
    char version[0x10]; // FilePackVer3.0
    DWORD Size; // maybe
    QWORD EntryPoint; // probably 
}
```

然后试着写解出来的HashData结构体也就是`8hrxxx`这一串开头的结构
是通过日志发现读取的0x440大小的数据就是这个`HashData`
`读取文件   句柄:3AC   缓冲:19F85C  字节数:440`

大致观察一下结构可以注意到一个点 
![img](万华镜逆向(初试)/images/image-62.png)
这个`HashData`结构体的最后一个成员就是 `FilePack`结构体

然后后面有个`CopyFrom` 日志输出 `读取文件   句柄:3AC   缓冲:27BB580  字节数:14D`
而指向的是 `HashVer1.4`这块
所以可以推出`8hrxx`0x20后的`4D 01 00 00`就是读取的字节数size

```c++
struct HashData{
    char HashHead[0x20]; // 8hrxxx
    DWORD HashVerSize; // 从HashVer1.4读取的字节数

    FilePack filepack;
}
```

其他的目前还原不出来... 继续看

### HashVer的处理

从这里开始就很不好分析了
![img](万华镜逆向(初试)/images/image-64.png)
主要是一个函数内有多种操作 步进不现实 步过又容易漏...
注意到`488201`处`CopyFrom`读取了Hashver部分的数据
后面的setpoint结合后面的`[eax+4]`知道指向了HashVer的头部 然后进入那个多功能的函数
在这里
![img](万华镜逆向(初试)/images/image-65.png)
看到拷贝了0x20的HashVer 但是对比时只用到了0x10 所以后0x10是用于其他目的
然后一直对比到ver1.4
又进行了一次Read
后面对读入的数据处理
![img](万华镜逆向(初试)/images/image-66.png)

后面建了一个类 然后用CopyFrom对类写入了数据
这里学到一个技巧 x32dbg用添加标签对函数重命名 更方便查看
![img](万华镜逆向(初试)/images/image-67.png)
把 `sub_48318C`重命名为 `decrypt`
这个是前面出现过的一个解密函数 当时解出来的就是 HashData的开头`8xx`

然后后面又出现了一个跟`decrypt`结构很相似的解密函数 `decrypt2`

```c++
int __fastcall sub_483D80(int a1, char a2, int a3, int a4)
{
  int result; // eax
  int savedregs; // [esp+8h] [ebp+0h] BYREF

  if ( a2 )
    result = sub_483410(&savedregs);
  else
    result = sub_483988(&savedregs);
  return result;
}
```

可以看到这里根据`a2`的不同选择不同的算法
![img](万华镜逆向(初试)/images/image-68.png)
这里的eax传的是前面建的与HashVer数据有关的类 解密返回的结果也是一个类

前面有个很关键的点看漏了 当对`HashVer`解密后 会check`HashVer1.4`后的第5个DWORD值
分1,2,other 不同跳转
![img](万华镜逆向(初试)/images/image-69.png)

1 就是我们的`decrypt2`
其中decrypt2的函数
`sub_483410`:

```c++
Classes::TStream *__cdecl sub_483410(int a1)
{
  char *v1; // eax
  char *v2; // esi
  Classes::TStream *v3; // ebx
  char *v4; // esi
  unsigned int v5; // ebx
  int v6; // edi
  int v7; // ebx
  char v9[256]; // [esp+Ch] [ebp-424h]
  char v10[512]; // [esp+10Ch] [ebp-324h] BYREF
  char v11[256]; // [esp+30Ch] [ebp-124h] BYREF
  int v12; // [esp+40Ch] [ebp-24h] BYREF
  unsigned int v13; // [esp+410h] [ebp-20h] BYREF
  unsigned int v14; // [esp+414h] [ebp-1Ch]
  _BYTE *v15; // [esp+418h] [ebp-18h]
  Classes::TStream *v16; // [esp+41Ch] [ebp-14h]
  unsigned int v17; // [esp+420h] [ebp-10h] BYREF
  int v18; // [esp+424h] [ebp-Ch]
  int v19; // [esp+428h] [ebp-8h]
  unsigned __int8 v20; // [esp+42Fh] [ebp-1h]

  Classes::TStream::SetPosition(*(Classes::TStream **)(a1 - 4), 0i64);
  v19 = 0;
  v1 = v10;
  do
    *v1++ = v19++;
  while ( v19 != 256 );
  (*(void (__fastcall **)(_DWORD, unsigned int *, int))(**(_DWORD **)(a1 - 4) + 12))(*(_DWORD *)(a1 - 4), &v13, 4);
  if ( v13 == 0xFF435031 )
  {
    (*(void (__fastcall **)(_DWORD, int *, int))(**(_DWORD **)(a1 - 4) + 12))(*(_DWORD *)(a1 - 4), &v12, 4);
    (*(void (__fastcall **)(_DWORD, unsigned int *, int))(**(_DWORD **)(a1 - 4) + 12))(*(_DWORD *)(a1 - 4), &v17, 4);
    v2 = (char *)(*(_DWORD *)(*(_DWORD *)(a1 - 4) + 4) + 12);
  }
  else
  {
    if ( *(_BYTE *)(a1 - 5) )
    {
      if ( *(_BYTE *)(a1 + 8) )
        System::TObject::Free(*(System::TObject **)(a1 - 4));
      return 0;
    }
    v12 = 0;
    v17 = v13;
    v2 = (char *)(*(_DWORD *)(*(_DWORD *)(a1 - 4) + 4) + 4);
  }
  if ( v17 <= 0x20000000 )
  {
    v16 = (Classes::TStream *)TObject::`...'((VMT *)&cls_Classes_TMemoryStream, 1);
    (*(void (__fastcall **)(Classes::TStream *, unsigned int))(*(_DWORD *)v16 + 4))(v16, v17);
    Classes::TStream::SetPosition(v16, 0i64);
    v15 = (_BYTE *)*((_DWORD *)v16 + 1);
    v14 = *(_DWORD *)(*(_DWORD *)(a1 - 4) + 4) + (***(int (__fastcall ****)(_DWORD))(a1 - 4))(*(_DWORD *)(a1 - 4));
LABEL_36:
    if ( (unsigned int)v2 < v14 )
    {
      v20 = *v2;
      v4 = v2 + 1;
      idr617538_Move(v10, v11, 256);
      v5 = 0;
      while ( 1 )
      {
        if ( v20 > 0x7Fu )
        {
          v5 += v20 - 127;
          v20 = 0;
        }
        if ( v5 > 0xFF )
          break;
        v6 = v20 + 1;
        do
        {
          v11[v5] = *v4++;
          if ( v5 != (unsigned __int8)v11[v5] )
            v10[v5 + 256] = *v4++;
          ++v5;
          --v6;
        }
        while ( v6 );
        if ( v5 > 0xFF )
          break;
        v20 = *v4++;
      }
      if ( (v12 & 1) == 1 )
      {
        v18 = *(unsigned __int16 *)v4;
        v2 = v4 + 2;
      }
      else
      {
        v18 = *(_DWORD *)v4;
        v2 = v4 + 4;
      }
      v19 = 0;
      while ( 1 )
      {
        if ( v19 )
        {
          v7 = (unsigned __int8)v9[--v19];
        }
        else
        {
          if ( !v18 )
            goto LABEL_36;
          --v18;
          v7 = (unsigned __int8)*v2++;
        }
        if ( v7 == (unsigned __int8)v11[v7] )
        {
          *v15++ = v7;
        }
        else
        {
          v9[v19++] = v10[v7 + 256];
          v9[v19++] = v11[v7];
        }
      }
    }
    if ( *(_BYTE *)(a1 + 8) )
      System::TObject::Free(*(System::TObject **)(a1 - 4));
    v3 = v16;
    Classes::TStream::SetPosition(v16, 0i64);
  }
  else
  {
    if ( *(_BYTE *)(a1 + 8) )
      System::TObject::Free(*(System::TObject **)(a1 - 4));
    v3 = 0;
  }
  return v3;
}
```

可以看出是一个比较复杂的算法 但是既然是解压函数 我们就不需要逆向算法了
关注下这个算法的流程
先计算了一个东西 然后 check `if ( v13 == 0xFF435031 )`
然后一大堆简洁调用函数
接着check如果size满足条件 `if ( v17 <= 0x20000000 )` ...

结合x32dbg动调分析
可以知道先建了一个表 然后循环(采用的是goto)来解密
但并没有找到教程虽说的解密后的数据...
翻内存倒是翻到有jpeg字段 应该是解密了部分资源出来了
跳出这个函数继续往后分析

跳出这个函数来到这里
![img](万华镜逆向(初试)/images/image-70.png)






sub_487680->decrypt3_hash

跟踪到这里面
![img](万华镜逆向(初试)/images/image-71.png)
发现已经解出文件名了
![img](万华镜逆向(初试)/images/image-72.png)

decrypt3在IDA交叉引用很容易找到 就是 `sub_4878D4`

```c++
int __cdecl decrypt3(int a1)
{
  int v1; // edi
  int v2; // esi
  char *v3; // ebx
  int result; // eax
  int v5; // ecx
  int v6; // edx
  __m64 *v7; // edi
  int v8; // esi
  __m64 v9; // mm7
  __m64 v10; // mm7
  __m64 v11; // mm1
  int v12; // [esp-4h] [ebp-CCh]
  char v13[164]; // [esp+Ch] [ebp-BCh] BYREF
  __m64 v14; // [esp+B0h] [ebp-18h]
  char *v15; // [esp+B8h] [ebp-10h]
  __m64 *v16; // [esp+BCh] [ebp-Ch]
  int v17; // [esp+C0h] [ebp-8h]
  int v18; // [esp+C4h] [ebp-4h]

  v1 = a1 - 8;
  decrypt3_hash(a1);
  v2 = 41;
  v3 = v13;
  do
  {
    *(_DWORD *)v3 = sub_4872C0(*(_DWORD *)(*(_DWORD *)v1 + 0x164));
    v3 += 4;
    --v2;
  }
  while ( v2 );
  v14.m64_i32[0] = sub_4872C0(*(_DWORD *)(*(_DWORD *)v1 + 356));
  v14.m64_i32[1] = sub_4872C0(*(_DWORD *)(*(_DWORD *)v1 + 356));
  result = *(_DWORD *)(a1 - 4) >> 3;
  v18 = result;
  if ( result )
  {
    v16 = *(__m64 **)(a1 - 12);
    v15 = v13;
    v17 = 8 * (sub_4872C0(*(_DWORD *)(*(_DWORD *)v1 + 356)) & 0xF);
    v12 = v17;
    v5 = v18;
    v6 = v17;
    v7 = v16;
    v8 = (int)v15;
    v9 = v14;
    do
    {
      v10 = _m_paddd(_m_pxor(v9, *(__m64 *)(v6 + v8)), *(__m64 *)(v6 + v8));
      v11 = _m_pxor((__m64)v7->m64_u64, v10);
      v7->m64_u64 = (unsigned __int64)v11;
      v9 = _m_paddw(_m_pslldi(_m_pxor(_m_paddb(v10, v11), v11), 1u), v11);
      ++v7;
      v6 = ((_BYTE)v6 + 8) & 0x7F;
      --v5;
    }
    while ( v5 );
    _m_empty();
    result = v12;
  }
  return result;
}
```

但跟教程的汇编好多对不上... gg

近月2到这里就结束了... 但是还有好多地方没有理清楚

--- 太难了 ---

但还是得继续... 想了想 也只能用x32dbg/olldbg  IDA一不好输出日志 二不好返回用户领空
慢慢磨吧...

